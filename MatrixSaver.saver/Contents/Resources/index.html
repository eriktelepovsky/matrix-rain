<!DOCTYPE html>
<html lang="en">
    <head>
        <style>
            html, body { margin: 0; background: #000; }
        </style>
    </head>
    <body>
        <!-- fillStyle is ignored for fillText in WallpaperAgent's WebKit;
             text always renders in system color (white). This SVG filter
             converts grayscale pixels to green so the effect looks right
             regardless of fillStyle behavior. Black stays black. -->
        <svg width="0" height="0" style="position:absolute">
            <defs>
                <filter id="green" color-interpolation-filters="sRGB">
                    <feColorMatrix type="matrix"
                        values="0 0 0 0 0
                                1 0 0 0 0
                                0 0 0 0 0
                                0 0 0 1 0"/>
                </filter>
            </defs>
        </svg>
        <canvas id="c" style="filter:url(#green)"></canvas>
        <script>
            const config = {
                fontSize:    14,
                intervalMs:  50,
                fadeSpeed:   0.04,
                speedMin:    0.5,
                speedMax:    2.0,
                resetChance: 0.5,
                chars: 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン0123456789',
            };

            const canvas = document.getElementById('c');
            const ctx    = canvas.getContext('2d');
            let columns, drops, speeds, grid, prevHeads;

            function init() {
                canvas.width  = screen.width;
                canvas.height = screen.height;
                columns   = Math.floor(canvas.width / config.fontSize);
                drops     = Array.from({length: columns}, () => Math.random() * -(canvas.height / config.fontSize));
                speeds    = Array.from({length: columns}, () => config.speedMin + Math.random() * (config.speedMax - config.speedMin));
                grid      = Array.from({length: columns}, () => ({}));
                prevHeads = new Array(columns).fill(-1);
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            function tick() {
                // Fade existing pixels toward black
                ctx.globalAlpha = config.fadeSpeed;
                ctx.fillStyle   = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.font = config.fontSize + 'px monospace';

                for (let i = 0; i < columns; i++) {
                    const x    = i * config.fontSize;
                    const head = Math.floor(drops[i]);

                    // Trail chars at 75% opacity — slightly dimmer than head
                    ctx.globalAlpha = 0.75;
                    for (let r = Math.max(0, prevHeads[i]); r < head; r++) {
                        if (!grid[i][r]) grid[i][r] = config.chars[Math.floor(Math.random() * config.chars.length)];
                        ctx.fillText(grid[i][r], x, r * config.fontSize);
                    }

                    // Head char at full brightness
                    if (head >= 0) {
                        ctx.globalAlpha = 1;
                        if (!grid[i][head]) grid[i][head] = config.chars[Math.floor(Math.random() * config.chars.length)];
                        ctx.fillText(grid[i][head], x, head * config.fontSize);
                    }

                    prevHeads[i] = head;

                    if (drops[i] * config.fontSize > canvas.height && Math.random() < config.resetChance) {
                        drops[i]     = 0;
                        prevHeads[i] = -1;
                    }
                    drops[i] += speeds[i];
                }

                ctx.globalAlpha = 1;
            }

            init();
            const mc = new MessageChannel();
            let lastTick = 0;
            mc.port1.onmessage = () => {
                const now = performance.now();
                if (now - lastTick >= config.intervalMs) { tick(); lastTick = now; }
                mc.port2.postMessage(null);
            };
            mc.port2.postMessage(null);
        </script>
    </body>
</html>
